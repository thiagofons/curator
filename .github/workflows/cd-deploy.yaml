name: ðŸš€ CD - Deploy

on:
  workflow_run:
    workflows: ["ðŸ¤– CI - Pull Request Validation"]
    types: [completed]
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read
  packages: write

concurrency:
  group: production-deploy
  cancel-in-progress: false

jobs:
  gate:
    name: ðŸ”’ CI Gate
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    steps:
      - name: âœ… CI passed
        run: echo "CI workflow passed â€” proceeding with deployment"

  provision:
    name: ðŸ—ï¸ Terraform
    needs: [gate]
    runs-on: ubuntu-latest
    outputs:
      infra_changed: ${{ steps.changes.outputs.infra_changed }}
      floating_ip: ${{ steps.tf_output.outputs.floating_ip }}
      db_host: ${{ steps.tf_output.outputs.db_host }}
      project_ref: ${{ steps.tf_output.outputs.project_ref }}
    steps:
      - name: â¬‡ï¸ Checkout Repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ðŸ” Check for infrastructure changes
        id: changes
        run: |
          if git diff --name-only HEAD^ HEAD | grep -q '^infrastructure/'; then
            echo "infra_changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "infra_changed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: ðŸ”§ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.9"

      - name: ðŸ”§ Terraform Init
        working-directory: infrastructure
        run: |
          terraform init -input=false \
            -backend-config="bucket=${{ secrets.HOS_BUCKET }}" \
            -backend-config="key=production/terraform.tfstate" \
            -backend-config="access_key=${{ secrets.HOS_ACCESS_KEY_ID }}" \
            -backend-config="secret_key=${{ secrets.HOS_SECRET_ACCESS_KEY }}"

      - name: ðŸ“‹ Terraform Apply
        if: steps.changes.outputs.infra_changed == 'true' || github.event_name == 'workflow_dispatch'
        working-directory: infrastructure
        env:
          TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
          TF_VAR_ssh_public_key: ${{ secrets.HETZNER_SSH_PUBLIC_KEY }}
          TF_VAR_supabase_access_token: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          TF_VAR_supabase_organization_id: ${{ secrets.SUPABASE_ORG_ID }}
          TF_VAR_supabase_db_password: ${{ secrets.DATABASE_PASSWORD }}
        run: |
          terraform plan -out=tfplan
          terraform apply -auto-approve tfplan

      - name: ðŸ“¤ Read Terraform Outputs
        id: tf_output
        working-directory: infrastructure
        run: |
          echo "floating_ip=$(terraform output -raw floating_ip)" >> "$GITHUB_OUTPUT"
          echo "db_host=$(terraform output -raw db_host)" >> "$GITHUB_OUTPUT"
          echo "project_ref=$(terraform output -raw project_ref)" >> "$GITHUB_OUTPUT"

  build-and-push:
    name: ðŸ³ Build ${{ matrix.app }}
    needs: [gate]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - app: api
            dockerfile: ./apps/backend/api/Dockerfile
            image_name: curator-api
          - app: cms
            dockerfile: ./apps/backend/cms/Dockerfile
            image_name: curator-cms

    steps:
      - name: â¬‡ï¸ Checkout Repo
        uses: actions/checkout@v4

      - name: ðŸ·ï¸ Get version from package.json
        id: pkg
        run: |
          VERSION=$(node -p "require('./apps/backend/${{ matrix.app }}/package.json').version")
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

      - name: ðŸ³ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ðŸ”‘ Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ—ï¸ Build and Push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ matrix.dockerfile }}
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/${{ matrix.image_name }}:latest
            ghcr.io/${{ github.repository_owner }}/${{ matrix.image_name }}:${{ steps.pkg.outputs.version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: ðŸš€ Deploy to K3s
    needs: [build-and-push, provision]
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: ðŸš€ Update Instance & Deploy
        uses: appleboy/ssh-action@v1
        env:
          DATABASE_HOST: ${{ needs.provision.outputs.db_host }}
          PROJECT_REF: ${{ needs.provision.outputs.project_ref }}
          FLOATING_IP: ${{ needs.provision.outputs.floating_ip }}
          # Database
          DATABASE_DB: ${{ secrets.DATABASE_DB }}
          DATABASE_USER: ${{ secrets.DATABASE_USER }}
          DATABASE_MASTER_PASSWORD: ${{ secrets.DATABASE_MASTER_PASSWORD }}
          DATABASE_API_PASSWORD: ${{ secrets.DATABASE_API_PASSWORD }}
          DATABASE_CMS_PASSWORD: ${{ secrets.DATABASE_CMS_PASSWORD }}
          DATABASE_CRM_PASSWORD: ${{ secrets.DATABASE_CRM_PASSWORD }}
          DATABASE_API_URL: ${{ secrets.DATABASE_API_URL }}
          DATABASE_CMS_URL: ${{ secrets.DATABASE_CMS_URL }}
          DATABASE_CRM_URL: ${{ secrets.DATABASE_CRM_URL }}
          # Application secrets
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_SECRET: ${{ secrets.GOOGLE_SECRET }}
          PAYLOAD_SECRET: ${{ secrets.PAYLOAD_SECRET }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          METABASE_SECRET_KEY: ${{ secrets.METABASE_SECRET_KEY }}
          # Infrastructure
          GHCR_PAT: ${{ secrets.GHCR_PAT }}
          REPO_OWNER: ${{ github.repository_owner }}
          LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}
        with:
          host: ${{ needs.provision.outputs.floating_ip }}
          username: root
          key: ${{ secrets.HETZNER_SSH_KEY }}
          envs: DATABASE_HOST,PROJECT_REF,FLOATING_IP,DATABASE_DB,DATABASE_USER,DATABASE_MASTER_PASSWORD,DATABASE_API_PASSWORD,DATABASE_CMS_PASSWORD,DATABASE_CRM_PASSWORD,DATABASE_API_URL,DATABASE_CMS_URL,DATABASE_CRM_URL,JWT_SECRET,GOOGLE_CLIENT_ID,GOOGLE_SECRET,PAYLOAD_SECRET,REDIS_PASSWORD,METABASE_SECRET_KEY,GHCR_PAT,REPO_OWNER,LETSENCRYPT_EMAIL
          script: |
            set -e
            export KUBECONFIG=/root/.kube/config
            export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

            # 0. Bootstrap: instala K3s se ausente (failsafe â€” normalmente feito pelo user-data)
            if ! command -v kubectl &>/dev/null || ! kubectl get nodes &>/dev/null 2>&1; then
              echo "=== K3s nÃ£o encontrado â€” instalando ==="
              curl -sfL https://get.k3s.io | sh -
              sleep 30
              mkdir -p /root/.kube
              cp /etc/rancher/k3s/k3s.yaml /root/.kube/config
              chmod 600 /root/.kube/config
            fi

            # 1. Atualiza cÃ³digo fonte
            if [ ! -d ~/curator ]; then
              git clone "https://github.com/${REPO_OWNER}/curator.git" ~/curator
            fi
            cd ~/curator
            git pull origin main

            # 2. Inicializa DB Supabase (idempotente)
            chmod +x ./scripts/init-db.sh
            env \
              DATABASE_HOST="$DATABASE_HOST" \
              DATABASE_DB="$DATABASE_DB" \
              DATABASE_USER="$DATABASE_USER" \
              DATABASE_MASTER_PASSWORD="$DATABASE_MASTER_PASSWORD" \
              DATABASE_API_PASSWORD="$DATABASE_API_PASSWORD" \
              DATABASE_CMS_PASSWORD="$DATABASE_CMS_PASSWORD" \
              DATABASE_CRM_PASSWORD="$DATABASE_CRM_PASSWORD" \
              ./scripts/init-db.sh

            # 3. Cria namespace curator
            kubectl create namespace curator --dry-run=client -o yaml | kubectl apply -f -

            # 4. Cria secret para pull de imagens do GHCR
            kubectl create secret docker-registry ghcr-credentials \
              --docker-server=ghcr.io \
              --docker-username="${REPO_OWNER}" \
              --docker-password="${GHCR_PAT}" \
              --namespace=curator \
              --dry-run=client -o yaml | kubectl apply -f -

            # 5. Configura Traefik ACME (kube-system â€” fora do overlay curator)
            ACME_EMAIL="$LETSENCRYPT_EMAIL" envsubst \
              < k8s/overlays/production/traefik-config.yaml \
              | kubectl apply -f -

            # 6. Cria os arquivos secrets.env (nÃ£o commitados) para o overlay de produÃ§Ã£o
            mkdir -p k8s/overlays/production/secrets

            cat > k8s/overlays/production/secrets/api.env << EOF
            DATABASE_URL=${DATABASE_API_URL}
            REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379
            JWT_SECRET=${JWT_SECRET}
            GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}
            GOOGLE_SECRET=${GOOGLE_SECRET}
            GOOGLE_CALLBACK_URL=https://api.curator.com.br/auth/google/callback
            EOF

            cat > k8s/overlays/production/secrets/cms.env << EOF
            DATABASE_CMS_URL=${DATABASE_CMS_URL}
            PAYLOAD_SECRET=${PAYLOAD_SECRET}
            PAYLOAD_SERVER_URL=https://cms.curator.com.br
            EOF

            cat > k8s/overlays/production/secrets/redis.env << EOF
            REDIS_PASSWORD=${REDIS_PASSWORD}
            EOF

            cat > k8s/overlays/production/secrets/metabase.env << EOF
            MB_DB_CONNECTION_URI=${DATABASE_CRM_URL}
            MB_ENCRYPTION_SECRET_KEY=${METABASE_SECRET_KEY}
            EOF

            # 7. Atualiza image tags no overlay de produÃ§Ã£o (via kustomize)
            API_VERSION=$(node -p "require('./apps/backend/api/package.json').version")
            CMS_VERSION=$(node -p "require('./apps/backend/cms/package.json').version")

            cd k8s/overlays/production
            kustomize edit set image \
              "ghcr.io/${REPO_OWNER}/curator-api:${API_VERSION}" \
              "ghcr.io/${REPO_OWNER}/curator-cms:${CMS_VERSION}"
            cd ~/curator

            # 8. Aplica o overlay de produÃ§Ã£o
            kubectl apply -k k8s/overlays/production/

            # 9. Aguarda rollouts completarem
            kubectl rollout status deployment/api      -n curator --timeout=5m
            kubectl rollout status deployment/cms      -n curator --timeout=5m
            kubectl rollout status deployment/metabase -n curator --timeout=5m
            kubectl rollout status statefulset/redis   -n curator --timeout=3m

            echo "=== Deploy concluÃ­do com sucesso ==="
            kubectl get pods,ingress -n curator
