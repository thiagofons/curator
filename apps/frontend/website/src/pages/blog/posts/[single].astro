---
import PostSingle from "@/components/blog/PostSingle.astro";
import Base from "@/layouts/Base.astro";
import {
  getPayloadAuthorBySlug,
  getPayloadPostBySlug,
  getPayloadPosts,
  type AdaptedPost,
} from "@/lib/payload";

export async function getStaticPaths() {
  try {
    const posts = await getPayloadPosts();

    return posts
      .filter((post: AdaptedPost) => Boolean(post?.slug))
      .map((post: AdaptedPost) => ({
        params: {
          single: post.slug,
        },
      }));
  } catch (error) {
    console.error("Failed to generate static paths for blog posts:", error);
    return [];
  }
}

interface Props {
  post?: AdaptedPost;
}

const slug = Astro.params.single;

let post: AdaptedPost = Astro.props.post;

if (!post?.slug || post.slug !== slug) {
  try {
    post = (await getPayloadPostBySlug(slug)) as AdaptedPost;
  } catch (error) {
    console.error(`Failed to fetch blog post by slug "${slug}":`, error);
  }
}

if (!post?.slug) {
  return Astro.redirect("/blog");
}

// Fetch related posts and author in parallel
const [allPosts, author] = await Promise.all([
  getPayloadPosts(),
  post.data.authorSlugs?.[0]
    ? getPayloadAuthorBySlug(post.data.authorSlugs[0]).catch(() => null)
    : Promise.resolve(null),
]);

const relatedPosts = allPosts.filter((p) => p.slug !== post.slug);

const { title, meta_title, description, image } = post.data;
const { contentHtml } = post;
---

<Base
  title={title || "Blog Post"}
  meta_title={meta_title || title}
  description={description}
  image={image}
  theme="dark"
>
  <PostSingle {post} {contentHtml} {relatedPosts} {author} />
</Base>
